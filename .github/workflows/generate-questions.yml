name: Generate Questions

on:
  workflow_dispatch:
    inputs:
      count:
        description: 'Number of questions to generate'
        required: true
        default: '20'

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude CLI
        run: npm install -g @anthropic-ai/claude-code

      - name: Get existing questions from Supabase
        id: existing
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          # Get all existing questions (full text for dedup)
          EXISTING=$(curl -s "${SUPABASE_URL}/rest/v1/questions?select=id,topic,lecture,question" \
            -H "apikey: ${SUPABASE_SERVICE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}")

          echo "$EXISTING" > /tmp/existing_questions.json

          # Get the max ID number for continuation
          MAX_ID=$(echo "$EXISTING" | jq -r '[.[].id | ltrimstr("q") | tonumber] | max // 0')
          NEXT_NUM=$((MAX_ID + 1))
          NEXT_ID=$(printf "q%03d" $NEXT_NUM)

          echo "next_id=$NEXT_ID" >> $GITHUB_OUTPUT
          echo "count=$(echo "$EXISTING" | jq 'length')" >> $GITHUB_OUTPUT

          # Build topic list for Claude context
          echo "$EXISTING" | jq -r '.[].topic' | sort -u > /tmp/existing_topics.txt

      - name: Read content files
        run: |
          echo "=== exam-gold.md ===" > /tmp/all_content.txt
          cat content/exam-gold.md >> /tmp/all_content.txt
          for i in 1 2 3 4 5 6; do
            echo "" >> /tmp/all_content.txt
            echo "=== lecture-${i}.md ===" >> /tmp/all_content.txt
            cat "content/lecture-${i}.md" >> /tmp/all_content.txt
          done

      - name: Generate questions with Claude
        env:
          CLAUDE_CODE_USE_BEDROCK: 0
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        run: |
          EXISTING_TOPICS=$(cat /tmp/existing_topics.txt)
          CONTENT=$(cat /tmp/all_content.txt)
          PROMPT_TEMPLATE=$(cat scripts/prompt-template.md)
          COUNT=${{ github.event.inputs.count }}
          NEXT_ID=${{ steps.existing.outputs.next_id }}

          FULL_PROMPT=$(cat <<ENDPROMPT
          ${PROMPT_TEMPLATE}

          ## Additional Instructions

          - Generate exactly ${COUNT} new questions.
          - ID_START = ${NEXT_ID}
          - Existing topics that must NOT be repeated:
          ${EXISTING_TOPICS}

          ## Lecture Content

          ${CONTENT}

          Return ONLY a valid JSON array. No text before or after.
          ENDPROMPT
          )

          claude -p --model opus --output-format json "$FULL_PROMPT" > /tmp/generated.json 2>/tmp/claude_stderr.log || true

          # Extract the JSON result from Claude's output
          if jq -e '.result' /tmp/generated.json > /dev/null 2>&1; then
            jq -r '.result' /tmp/generated.json > /tmp/questions_raw.txt
          else
            cp /tmp/generated.json /tmp/questions_raw.txt
          fi

          # Parse JSON array from output
          python3 -c "
          import json, re, sys
          text = open('/tmp/questions_raw.txt').read()
          match = re.search(r'\[[\s\S]*\]', text)
          if match:
              data = json.loads(match.group())
              json.dump(data, open('/tmp/questions.json', 'w'), ensure_ascii=False, indent=2)
              print(f'Parsed {len(data)} questions')
          else:
              print('ERROR: No JSON array found in output', file=sys.stderr)
              print('Raw output:', text[:500], file=sys.stderr)
              sys.exit(1)
          "

      - name: Deduplicate against existing questions
        run: |
          python3 -c "
          import json, sys
          from difflib import SequenceMatcher

          existing = json.load(open('/tmp/existing_questions.json'))
          new_qs = json.load(open('/tmp/questions.json'))

          existing_texts = [q['question'] for q in existing]
          existing_topics = [q['topic'] for q in existing]

          def is_duplicate(new_q):
              # Check exact question text match
              if new_q['question'] in existing_texts:
                  return True
              # Check fuzzy match on question text (>85% similar)
              for et in existing_texts:
                  if SequenceMatcher(None, new_q['question'], et).ratio() > 0.85:
                      print(f'  Fuzzy dup: {new_q[\"question\"][:60]}...')
                      return True
              # Check exact topic match
              if new_q['topic'] in existing_topics:
                  return True
              return False

          unique = [q for q in new_qs if not is_duplicate(q)]
          removed = len(new_qs) - len(unique)

          if removed > 0:
              print(f'Removed {removed} duplicate(s), keeping {len(unique)} unique questions')
              # Re-number IDs sequentially
              existing_ids = [q['id'] for q in existing]
              max_num = max([int(qid.lstrip('q')) for qid in existing_ids]) if existing_ids else 0
              for i, q in enumerate(unique):
                  q['id'] = f'q{max_num + 1 + i:03d}'
          else:
              print(f'No duplicates found, all {len(unique)} questions are unique')

          json.dump(unique, open('/tmp/questions_deduped.json', 'w'), ensure_ascii=False, indent=2)
          " || { echo "Dedup failed, using original"; cp /tmp/questions.json /tmp/questions_deduped.json; }

      - name: Insert questions into Supabase
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          QUESTIONS=$(cat /tmp/questions_deduped.json)
          COUNT=$(echo "$QUESTIONS" | jq 'length')

          if [ "$COUNT" -eq 0 ]; then
            echo "No questions to insert (all were duplicates)"
            exit 0
          fi

          echo "Inserting $COUNT questions..."

          # Insert in batches of 10
          for i in $(seq 0 9 $((COUNT - 1))); do
            BATCH=$(echo "$QUESTIONS" | jq ".[$i:$((i+10))]")
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${SUPABASE_URL}/rest/v1/questions" \
              -H "apikey: ${SUPABASE_SERVICE_KEY}" \
              -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}" \
              -H "Content-Type: application/json" \
              -H "Prefer: resolution=ignore-duplicates" \
              -d "$BATCH")

            HTTP_CODE=$(echo "$RESPONSE" | tail -1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            if [ "$HTTP_CODE" -ge 400 ]; then
              echo "Error inserting batch at $i: $BODY"
            else
              echo "Inserted batch at $i OK"
            fi
          done

          echo "Done!"

      - name: Summary
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          TOTAL=$(curl -s "${SUPABASE_URL}/rest/v1/questions?select=id" \
            -H "apikey: ${SUPABASE_SERVICE_KEY}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_KEY}" \
            -H "Prefer: count=exact" \
            -H "Range-Unit: items" \
            -H "Range: 0-0" \
            -I | grep -i content-range | grep -o '/[0-9]*' | tr -d '/')

          INSERTED=$(cat /tmp/questions_deduped.json | jq 'length')
          GENERATED=$(cat /tmp/questions.json | jq 'length')
          DUPES=$((GENERATED - INSERTED))

          echo "## Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Requested: ${{ github.event.inputs.count }}" >> $GITHUB_STEP_SUMMARY
          echo "- Generated by Claude: ${GENERATED}" >> $GITHUB_STEP_SUMMARY
          echo "- Duplicates removed: ${DUPES}" >> $GITHUB_STEP_SUMMARY
          echo "- Inserted: ${INSERTED}" >> $GITHUB_STEP_SUMMARY
          echo "- Total in database: ${TOTAL}" >> $GITHUB_STEP_SUMMARY
